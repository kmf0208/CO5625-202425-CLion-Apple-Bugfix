#pragma once

#include "Requirements.h"
#include <vector>
#include <algorithm>
#include <list>
#include <fstream>

const std::string test_file = "template/tests.txt";

std::vector<std::string> generateRandomStringFile(int numChars, int inverseNewlineProbability, std::string filename, bool mixedCase = false) {
	std::vector<std::string> result = { "" };
	for (int i = 0; i < numChars; ++i) {
		result.back().push_back(rand() % 26 + 'a');
		if (rand() % inverseNewlineProbability < 1) {
			result.push_back("");
		}
	}
	result.pop_back();
	std::sort(result.begin(), result.end());
	auto it = std::unique(result.begin(), result.end());
	result.erase(it, result.end());

	std::ofstream ofs(filename);
	for (auto i : result)
		ofs << i << "\n";
	ofs.close();
	return result;
}

template<class T>
	requires hasGetCity<T> && hasConstructor<T>
bool checkGetCity(std::list<std::string>& messages) {
	std::vector<std::string> data = generateRandomStringFile(1000, 10, test_file);
	T cities(test_file);
	for (int i = 0; i < data.size(); i++) {
		std::string city = cities.getCity(data[i][0]);
		if (city.empty() || city[0] != data[i][0] || std::find(data.begin(), data.end(), city) == data.end()) {
			messages.push_back("Invalid cities produced by getCity()");
			return false;
		}
	}
	return true;
}

template<class T>
bool checkGetCity(std::list<std::string>& messages) {
	return false;
}

template<class T>
	requires hasCheckCity<T>&& hasConstructor<T>
bool checkCityTests(std::list<std::string>& messages) {
	std::vector<std::string> data = generateRandomStringFile(1000, 10, test_file);
	T cities(test_file);
	for (auto i : data)
		if (!cities.checkCity(i)) {
			messages.push_back("All cities should be valid at the beginning of the game");
			return false;
		}
	if (cities.checkCity("hello_&%^4b")) {
		messages.push_back("Invalid cities should not be marked as correct");
		return false;
	}
	return true;
}

template<class T>
bool checkCityTests(std::list<std::string>& messages) {
	return false;
}

template<class T>
	requires hasCheckCity<T>&& hasMarkUsed<T>&& hasConstructor<T>
bool checkUsedTests(std::list<std::string>& messages) {
	std::vector<std::string> data = generateRandomStringFile(500, 10, test_file);
	T cities(test_file);
	for (auto i : data) {
		if (!cities.checkCity(i)) {
			messages.push_back( "All strings should be valid at the beginning of the game");
			return false;
		}
		cities.markUsed(i);
		if (cities.checkCity(i)) {
			messages.push_back("Cities should become invalid after being marked as used");
			return false;
		}
	}
	return true;
}

template<class T>
bool checkUsedTests(std::list<std::string>& messages) {
	return false;
}



template<class T>
	requires hasGetCity<T>&& hasMarkUsed<T>&& hasConstructor<T>
bool checkGenAfterUsed(std::list<std::string>& messages) {
	std::vector<std::string> data = generateRandomStringFile(500, 10, test_file);
	T cities(test_file);
	for (auto city : data) {
		cities.markUsed(city);
		for (int i = 0; i < 250; ++i)
			if (cities.getCity(city[0]) == city) {
				messages.push_back("Cities should not be generated by getCity() once they have been marked as used");
				return false;
			}
	}
	return true;
}

template<class T>
bool checkGenAfterUsed(std::list<std::string>& messages) {
	return false;
}

template<class T>
	requires hasConstructor<T>&& hasRestart<T>&& hasMarkUsed<T>&& hasCheckCity<T>
bool checkRestart(std::list<std::string>& messages) {
	std::vector<std::string> data = generateRandomStringFile(500, 10, test_file);
	T cities(test_file);
	std::ofstream ofs(test_file);
	ofs << "";
	ofs.close();
	for (auto i : data) {
		cities.markUsed(i);
		if (cities.checkCity(i))
			return false;
	}
	cities.markUsed("not a city");
	cities.restart();
	for (auto i : data) {
		if (!cities.checkCity(i)) {
			messages.push_back("All cities should become valid after restart (without rereading the file)");
			return false;
		}
	}
	if (cities.checkCity("Not a City")) {
		messages.push_back("Invalid cities should not become valid after restart. markUsed may need checking.");
		return false;
	}
	return true;
}

template<class T>
bool checkRestart(std::list<std::string>& messages) {
	return false;
}

template<class T>
	requires hasGetCity<T>&& hasCheckCity<T>&& hasConstructor<T>
bool fileRemove(std::list<std::string>& messages) {
	std::vector<std::string> data = generateRandomStringFile(1000, 10, test_file);
	T cities(test_file);
	std::ofstream ofs(test_file);
	ofs << "";
	ofs.close();
	int nonempty = 0;
	for (int i = 0; i < 5000; ++i) {
		char c = std::rand() % 26 + 'a';
		std::string city = cities.getCity(c);
		if (!city.empty() && !cities.checkCity(city)) {
			messages.push_back("checkCity() does not function correctly without file re-read");
			return false;
		}
		nonempty += !city.empty();
	}
	if (nonempty == 0) {
		messages.push_back("getCity() is producing empty strings without file re-read");
		return false;
	}
	return true;
}

template<class T>
bool fileRemove(std::list<std::string>& messages) {
	return false;
}

template<class T>
	requires hasGetCity<T> && hasMarkUsed<T> && hasConstructor<T>
bool allCities(std::list<std::string>& messages) {
	std::vector<std::string> data = generateRandomStringFile(200, 10, test_file);
	for (auto i: data) {
		T cities(test_file);
		std::string city = cities.getCity(i[0]);
		for (int j = 0; j < data.size(); j++) {
			if (i == city || city.empty())
				break;
			cities.markUsed(city);
			city = cities.getCity(i[0]);
		}
		if (i != city) {
			messages.push_back("Some strings are never generated at all");
			return false;
		}
	}
	return true;
}

template<class T>
bool allCities(std::list<std::string>& messages) {
	return false;
}

int doPrototypeTests(std::ostream& out) {
	out << "\033[0;1;4mPrototype\033[0m:\n\n\033[33m";
	if (!hasCheckCity<Prototype>)
		out << "\tcheckCity method has no compatible declaration\n";
	if (!hasMarkUsed<Prototype>)
		out << "\tmarkUsed method has no compatible declaration\n";
	if (!hasGetCity<Prototype>)
		out << "\tgetCity method has no compatible declaration\n";
	if (!hasConstructor<Prototype>)
		out << "\tNo std::string constructor present for Prototype class\n";
	if (!hasRestart<Prototype>)
		out << "\trestart method has no compatible declaration\n";
	if (allPrototypeMethods<Prototype>)
		out << "\t\033[32mAll methods have a compatible declaration\n";
	std::list<std::string> messages;
	int score = 0;
	score += 10 * checkCityTests<Prototype>(messages);
	score += 10 * checkGetCity<Prototype>(messages);
	score += 10 * (checkUsedTests<Prototype>(messages) & checkGenAfterUsed<Prototype>(messages));
	score += 20 * (checkGetCity<Prototype>(messages) & fileRemove<Prototype>(messages));
	score += 20 * (checkCityTests<Prototype>(messages) & checkUsedTests<Prototype>(messages) & checkRestart<Prototype>(messages));
	messages.sort();
	auto it = std::unique(messages.begin(), messages.end());
	messages.erase(it, messages.end());
	for (auto i : messages) {
		out << "\t\033[31m" << i << "\n";
	}
	if (messages.empty()) {
		out << "\t\033[32mNo implementation issues\n";
	}
	return score;
}